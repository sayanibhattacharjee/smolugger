package main

import (
	"bufio"
	"debug/elf"
	"debug/gosym"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"syscall"
)

var targetfile string
var line int
var pc uint64
var fn *gosym.Func
var symTable *gosym.Table
var regs syscall.PtraceRegs
var ws syscall.WaitStatus
var originalCode []byte
var breakpointSet bool

var interruptCode = []byte{0xCC}

func main() {
	target := "hello/hello"
	symTable = getSymbolTable(target)
	fn = symTable.LookupFunc("main.main")
	targetfile, line, fn = symTable.PCToLine(fn.Entry)
	run(target)
}

func run(target string) {
	var filename string

	cmd := exec.Command(target)
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Ptrace: true,
	}

	cmd.Start()
	err := cmd.Wait()
	if err != nil {
		fmt.Printf("Wait returned: %v\n\n", err)
	}

	pid := cmd.Process.Pid
	pgid, _ := syscall.Getpgid(pid)

	must(syscall.PtraceSetOptions(pid, syscall.PTRACE_O_TRACECLONE))

	if inputContinue(pid) {
		must(syscall.PtraceCont(pid, 0))
	} else {
		must(syscall.PtraceSingleStep(pid))
	}

	for {
		wpid, err := syscall.Wait4(-1*pgid, &ws, 0, nil)
		must(err)
		if ws.Exited() {
			if wpid == pid {
				break
			}
		} else {
			// We are only interested in tracing if we're stopped by a trap and
			// if the trap was generated by our breakpoint.
			// Cloning a child process also generates a trap, and we want to ignore that.
			if ws.StopSignal() == syscall.SIGTRAP && ws.TrapCause() != syscall.PTRACE_EVENT_CLONE {
				must(syscall.PtraceGetRegs(wpid, &regs))
				filename, line, fn = symTable.PCToLine(regs.Rip)
				fmt.Printf("Stopped at %s at %d in %s\n", fn.Name, line, filename)

				if breakpointSet {
					replaceCode(wpid, pc, originalCode)
					breakpointSet = false
				}

				if inputContinue(wpid) {
					must(syscall.PtraceCont(wpid, 0))
				} else {
					must(syscall.PtraceSingleStep(wpid))
				}
			} else {
				must(syscall.PtraceCont(wpid, 0))
			}
		}
	}
}

func replaceCode(pid int, breakpoint uint64, code []byte) []byte {
	original := make([]byte, len(code))
	syscall.PtracePeekData(pid, uintptr(breakpoint), original)
	syscall.PtracePokeData(pid, uintptr(breakpoint), code)
	return original
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}

func inputContinue(pid int) bool {
	sub := false
	scanner := bufio.NewScanner(os.Stdin)
	fmt.Printf("\n(C)ontinue, (S)tep, set (B)reakpoint or (Q)uit? > ")
	for {
		scanner.Scan()
		input := scanner.Text()
		switch strings.ToUpper(input) {
		case "C":
			return true
		case "S":
			return false
		case "B":
			fmt.Printf("  Enter line number in %s: > ", targetfile)
			sub = true
		case "Q":
			os.Exit(0)
		default:
			if sub {
				line, _ = strconv.Atoi(input)
				breakpointSet, originalCode = setBreak(pid, targetfile, line)
				return true
			}
			fmt.Printf("Unexpected input %s\n", input)
			fmt.Printf("\n(C)ontinue, (S)tep, set (B)reakpoint or (Q)uit? > ")
		}
	}
}

func setBreak(pid int, filename string, line int) (bool, []byte) {
	var err error
	pc, _, err = symTable.LineToPC(filename, line)
	if err != nil {
		fmt.Printf("Can't find pc for %s, %d\n", filename, line)
		return false, []byte{}
	}

	fmt.Printf("Stopping at %X\n", pc)
	return true, replaceCode(pid, pc, []byte{0xCC})
}

func getSymbolTable(prog string) *gosym.Table {
	exe, err := elf.Open(prog)
	if err != nil {
		panic(err)
	}
	defer exe.Close()

	addr := exe.Section(".text").Addr

	lineTableData, err := exe.Section(".gopclntab").Data()
	if err != nil {
		panic(err)
	}
	lineTable := gosym.NewLineTable(lineTableData, addr)
	if err != nil {
		panic(err)
	}

	symTableData, err := exe.Section(".gosymtab").Data()
	if err != nil {
		panic(err)
	}

	symTable, err := gosym.NewTable(symTableData, lineTable)
	if err != nil {
		panic(err)
	}

	return symTable
}
